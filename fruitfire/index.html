<!DOCTYPE html>
<html>
    <head>
        <title>FruitFire</title>
		<meta charset="UTF-8">
        <link rel="stylesheet" href="./style.css">
        <!-- <script src="https://lygia.xyz/resolve.js"></script>
        <script id="vert-id" type="x-shader/x-vertex">
            precision highp float;

            attribute vec2 aVertPos;
            attribute vec2 aTexCoord;

            uniform vec2 uRes;

            varying vec2 vTexCoord;

            void main() {
                gl_Position = vec4(aVertPos, 0, 1);

                vTexCoord = aTexCoord;
            }
        </script>
        <script id="frag-id" type="x-shader/x-fragment">
            precision highp float;
            
            uniform vec2 uRes;
            uniform sampler2D uTex;
            
            varying vec2 vTexCoord;
            
            void main() {
                gl_FragColor = texture2D(uTex, vTexCoord);
            }
        </script>
        <script id="frag-bg" type="x-shader/x-fragment">
            precision highp float;

            #include "lygia/math/permute.glsl"
            
            uniform vec2 uRes;
            uniform sampler2D uTex;
            
            varying vec2 vTexCoord;

            //	Classic Perlin 2D Noise 
            //	by Stefan Gustavson (https://github.com/stegu/webgl-noise)
            //
            vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}

            float cnoise(vec2 P, float C1, float C2, float C3, float C4){
                vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
                vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
                Pi = mod(Pi, C1); // To avoid truncation effects in permutation
                vec4 ix = Pi.xzxz;
                vec4 iy = Pi.yyww;
                vec4 fx = Pf.xzxz;
                vec4 fy = Pf.yyww;
                vec4 i = permute(permute(ix) + iy);
                vec4 gx = 2.0 * fract(i * C2) - 1.0;
                vec4 gy = abs(gx) - 0.5;
                vec4 tx = floor(gx + 0.5);
                gx = gx - tx;
                vec2 g00 = vec2(gx.x,gy.x);
                vec2 g10 = vec2(gx.y,gy.y);
                vec2 g01 = vec2(gx.z,gy.z);
                vec2 g11 = vec2(gx.w,gy.w);
                vec4 norm = C3 - C4 * 
                    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
                g00 *= norm.x;
                g01 *= norm.y;
                g10 *= norm.z;
                g11 *= norm.w;
                float n00 = dot(g00, vec2(fx.x, fy.x));
                float n10 = dot(g10, vec2(fx.y, fy.y));
                float n01 = dot(g01, vec2(fx.z, fy.z));
                float n11 = dot(g11, vec2(fx.w, fy.w));
                vec2 fade_xy = fade(Pf.xy);
                vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
                float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
                return 2.3 * n_xy;
            }

            float starField(vec2 coord, float C1, float C2, float C3, float C4) {
                float value = cnoise(coord * 0.025, C1, C2, C3, C4);
                value = pow(value, 10.0);
                value *= float(value > 0.5);
                value *= 2.0;
                return value;
            }

            uniform vec2 uResTex;
            uniform vec2 uCamera;

            vec2 texCoordToActual(vec2 coord) {
                float scale = max(uRes.x / uResTex.x, uRes.y / uResTex.y);
                return coord*uRes - (uResTex*scale - uRes)/2.0;
            }
            
            void main() {
                vec2 coord = texCoordToActual(vTexCoord);
                float value1 = starField(
                    0.5*coord + uCamera,
                    289.0,
                    0.243902439,
                    1.79284291400159,
                    0.85373472095314
                );
                float value2 = starField(
                    0.75*coord + uCamera,
                    289.0,
                    0.243902439,
                    1.79284291400159,
                    0.85373472095314
                );
                float value = value1 + value2 * 0.5;
                gl_FragColor = vec4(value, value, value, 1.0);
            }
        </script>
        <script id="frag-filter" type="x-shader/x-fragment">
            precision highp float;

            #include "lygia/math/permute.glsl"
            
            uniform vec2 uRes;
            uniform sampler2D uTex;
            
            varying vec2 vTexCoord;

            const float PI = 3.14159265;

            //	Classic Perlin 2D Noise 
            //	by Stefan Gustavson (https://github.com/stegu/webgl-noise)
            //
            vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}

            float cnoise(vec2 P){
                vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
                vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
                Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation
                vec4 ix = Pi.xzxz;
                vec4 iy = Pi.yyww;
                vec4 fx = Pf.xzxz;
                vec4 fy = Pf.yyww;
                vec4 i = permute(permute(ix) + iy);
                vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...
                vec4 gy = abs(gx) - 0.5;
                vec4 tx = floor(gx + 0.5);
                gx = gx - tx;
                vec2 g00 = vec2(gx.x,gy.x);
                vec2 g10 = vec2(gx.y,gy.y);
                vec2 g01 = vec2(gx.z,gy.z);
                vec2 g11 = vec2(gx.w,gy.w);
                vec4 norm = 1.79284291400159 - 0.85373472095314 * 
                    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
                g00 *= norm.x;
                g01 *= norm.y;
                g10 *= norm.z;
                g11 *= norm.w;
                float n00 = dot(g00, vec2(fx.x, fy.x));
                float n10 = dot(g10, vec2(fx.y, fy.y));
                float n01 = dot(g01, vec2(fx.z, fy.z));
                float n11 = dot(g11, vec2(fx.w, fy.w));
                vec2 fade_xy = fade(Pf.xy);
                vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
                float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
                return 2.3 * n_xy;
            }

            vec2 filter(vec2 pos) {
                return pos;
            }

            uniform vec2 uResTex;

            vec2 texCoordToActual(vec2 coord) {
                float scale = max(uRes.x / uResTex.x, uRes.y / uResTex.y);
                return coord*uRes - (uResTex*scale - uRes)/2.0;
            }
            
            void main() {
                gl_FragColor = texture2D(uTex, filter(((texCoordToActual(vTexCoord) / uResTex) - 0.5) * 2.0) / 2.0 + 0.5);
            }
        </script>
        <script id="frag-thresh" type="x-shader/x-fragment">
            precision highp float;
            
            uniform vec2 uRes;
            uniform sampler2D uTex;
            
            varying vec2 vTexCoord;

            const float PI = 3.14159265;
            const float sineWidth = 0.1;

            uniform float uThreshold;
            
            void main() {
                vec4 color = texture2D(uTex, vTexCoord);

                float brightness = (color.r + color.g + color.b) / 3.0;
                float dist = (brightness - uThreshold) * (PI / 2.0 / sineWidth);
                dist = min(PI/2.0, max(-PI/2.0, dist));

                color *= (sin(dist) + 1.0) / 2.0;
            
                gl_FragColor = color;
            }
        </script>
        <script id="frag-blur" type="x-shader/x-fragment">
            precision highp float;
            
            uniform vec2 uRes;
            uniform sampler2D uTex;
            
            varying vec2 vTexCoord;

            const float PI = 3.14159265;
            const int nSample = 5;

            uniform float uRadius;
            
            void main() {
                vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
                float total = 0.0;

                for (int x = -nSample; x <= nSample; x++) {
                    for (int y = -nSample; y <= nSample; y++) {
                        vec2 vTexCoordSample = vTexCoord + (vec2(float(x), float(y)) / float(nSample) * uRadius / uRes);
                        float weight = max(0.0, 1.0 - length(vec2(float(x), float(y)) / float(nSample)));
                        color += weight * texture2D(uTex, vTexCoordSample);
                        total += weight;
                    }
                }
                
                color /= total;
            
                gl_FragColor = color;
            }
        </script>
        <script id="frag-merge" type="x-shader/x-fragment">
            precision highp float;
            
            uniform vec2 uRes;
            uniform sampler2D uTex;
            
            varying vec2 vTexCoord;

            uniform sampler2D uBgTex;
            uniform sampler2D uAddTex;
            
            void main() {
                vec4 bgColor = texture2D(uBgTex, vTexCoord);
                vec4 texColor = texture2D(uTex, vTexCoord);
                vec4 addTexColor = texture2D(uAddTex, vTexCoord);
                vec4 addedTexColor = texColor + addTexColor;

                gl_FragColor = mix(bgColor, addedTexColor, addedTexColor.a);
            }
        </script> -->
    </head>
    <body>
        <canvas id="game"></canvas>
        <canvas id="game-overlay1"></canvas>
        <script type="module" src="./app.js"></script>
        <div id="main-menu">
            <div>
                <img tex="other:ui-title" type="og+outline">
                <img tex="other:ui-title" type="og+outline">
            </div>
            <button id="main-menu-play-btn">
                <img tex="other:ui-play" type="og+outline">
            </button>
        </div>
    </body>
</html>